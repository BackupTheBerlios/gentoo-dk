<?xml version='1.0' encoding="UTF-8"?>
<!-- $Header: /home/xubuntu/berlios_backup/github/tmp-cvs/gentoo-dk/Repository/docs/not_translated/Attic/diskless-howto.xml,v 1.2 2004/01/07 22:29:58 broeman Exp $ -->
<!DOCTYPE guide SYSTEM "/dtd/guide.dtd">

<guide link="/doc/da/diskless-howto.xml">

<title>Diskfrie noder med Gentoo</title>

<author title="Researcher">
    <mail link="ma53@drexel.edu">Michael Andrews</mail>
</author>
<author title="Reviewer">
    <mail link="swift@gentoo.org">Sven Vermeulen</mail>
</author>
<author title="Redaktør">
    <mail link="neysx@gentoo.org">Xavier Neys</mail>
</author>
<author title="Oversætter">
    <mail link="broeman@gentoo.org">Jesper Brodersen</mail>
</author>

<license/>

<abstract>
Denne HOWTO vil hjælpe dig med at opsætte diskfrie noder med Gentoo Linux 
</abstract>

<version>1.1</version>
<date>20. November, 2003</date>

<chapter>
<title>Introduktion</title>

<section>
<title>Om denne HOWTO</title>
<body>

<p>
Denne HOWTO vil hjælpe dig med sætte <e>diskfrie</e> arbejdsstationer op, baseret på
Gentoo Linux distributionen. Vi prøver at lave det så brugervenligt
som muligt, og sørger for Linux-newbien, fordi alle var én på et
specifikt tidspunkt :) Da en erfaren bruger sagtens kan samle de mange HOWTOer,
som er tilgængelige omkring diskfrie noder og netværk sammenlagt, håber vi at denne vejledning kan
lette installationen for alle interesserede brugere, nørd eller ej. 
</p>

</body>
</section>
<section>
<title>Hvad er en diskfri maskine?</title>
<body>

<p>
En diskfri maskine er en PC, uden nogen af de normale opstartsenheder, som
harddiske, floppydrev eller CDROM-drev. Den diskfrie node starter via et netværk og 
skal bruge en server, som kan levere det med lagerplads, som en lokal harddisk
ville gøre. Fra nu af, kalder vi serveren <e>master</e>, imens vi kalder den diskfrie 
maskine for <e>slave</e> (det ligger i navnet :). Slave-noden
kræver en netværksadapter, som understøtter PXE-opstart. De fleste kort understøtter
PXE og mange indebygget adaptere på bundkorte vil også virke.
</p>

</body>
</section>
<section>
<title>Før du starter</title>
<body>

<p>
Du burde have Gentoo installeret på din master-node, og nok plads på 
master til at gemme de filsystemer til slave-noderne.  
</p>

</body>
</section>
</chapter>

<chapter>
<title>Opsætning af master og slave</title>
<section>
<title>Om kerner</title>
<body>

<note>
Hvis du vil lave en cluster af dine noder ind til en openMosix-cluster, vær sikker på at du
bruger den patchet kerne til openMosix. Den kan findes i portage under
<path>sys-kernel/openmosix-sources</path>. Du burde læse vores <uri
link="openmosix-howto.xml">openMosix HOWTO</uri> for at lære om, hvordan du kompilerer din
kerne til openMosix.
</note>

<p>
Kernen er det software, som sidder imellem dit hardware og alt andet 
software, som du hentet på din maskine, er essensen af et kerne 
baseret operativsystem.  Når din computer er startet, vil BIOS udføre 
instruktioner, som er fundet på et reserveret opstartsplads på din harddisk. Disse 
instruktioner er typisk en boot-loader, som henter din kerne. Efter at din 
kerne er blevet hentet, er alle processer håndteret af kernen.  
</p>

<p>
Flere informationer om kerner og kerneopsætning kan du finde ved at
kigge på <uri link="http://www.tldp.org/HOWTO/Kernel-HOWTO.html">kernel
HOWTO</uri> (engelsk).
</p>

</body>
</section>
<section>
<title>Opsætning af masters kerne</title>
<body>

<p>
Masterens kerne kan være så stor og skræddersyet, som du ville ønske det, men
der er få krævede kerne-valgmuligheder, som du skal vælge. Gå ind i din 
kerne-opsætningsmednu ved at taste:
</p>

<pre caption="Redigering af masters kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Du burde få et grå og blåt grafisk grænseflade (GUI), som leverer en sikker alternative til manuelt
redigering af <path>/usr/src/linux/.config</path> filen.  Hvis din kerne er 
funktionsdygtig, så er det måske en god idé at gemme den nuværende opsætningsfil 
ved at afslutte GUIen og taste:
</p>

<pre caption="Backup af masters kerneopsætning">
# <i>cp .config .config_working</i>
</pre>

<p>
Gå ind i følgende under-menuer og være sikker på at de viste ting er afkrydset
som 'built-in' (og <e>IKKE</e> som moduler).  Indstillingerne, som er vist forneden er taget fra 
2.4.22 kerneversionen. Hvis du bruger en anden version, så kan teksten eller opstillingen
være anderledes. Vær sikker på at du vælger mindst dem vist forneden.
</p>

<pre caption="masters kerneindstillinger">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers


Networking options ---&gt;
  &lt;*&gt; Packet socket
  [ ]   Packet socket: mmapped IO
  &lt; &gt; Netlink device emulation
  [ ] Network packet filtering (replaces ipchains)
  [ ] Socket Filtering
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting

  
File systems ---&gt;
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot    
  Network File Systems  ---&gt;
    &lt;*&gt; NFS server support
    [*]   Provide NFSv3 server support
</pre>

<note>
Disse kerneopsætningsindstillinger skulle kun blive tilføjet dit systemspecifikke 
opsætningsindstillinger og er ikke ment til at erstarte din egen kernes
indstillinger komplet.
</note>

<p>
Efter at du har genindstillet masters kerne, vil du få brug for at genbygge den: 
</p>

<pre caption="Genkompilering af masters kerne og moduler">
# <i>make dep</i>
# <i>make clean bzImage modules modules_install</i>
<comment>(Vær sikker på at /boot er mounted, før du kopierer til den)</comment>
# <i>cp arch/i386/boot/bzImage /boot/bzImage-master</i>
# <i>cp System.map /boot/System.map-master</i>
</pre>

<p>
Tilføj så en punkt for den nye kerne i <path>lilo.conf</path> eller
<path>grub.conf</path>, afhængigt af hvilken boot-loader, som du bruger og lav
den nye kerne, valgt som standard. Nu da den nye bzImage er blevet kopieret til dit
boot-bibliotek, er alt hvad du skal gøre er, at genstarte systemet for at hente
disse nye indstillinger.
</p>

</body>
</section>
<section>
<title>Om slaves kerne</title>
<body>

<p>
Det er anbefalet, at du kompilerer slaves kerne uden nogen moduler, idet at
hente og indstille dem via en fjern-kontroleret opstart er svært og en unødvendig
process.  I tilføjelse af dette, burde slaves kerne være så lille og kompakt som
muligt, for at kunne opstarte effektivt fra netværket. Vi skal til at kompilere
slaves kerne i det samme sted, som master var opsat.
</p>

<p>
For at undgå misforståelser og spilde tid, er det sikkert en god idé at lave en backup af 
masters opsætningsfil ved at taste:
</p>

<pre caption="Backup af masters kerneopsætning">
# <i>cp /usr/src/linux/.config /usr/src/linux/.config_master</i>
</pre>

<p>
Nu vil vi til at opsætte slaves kerne på den samme måde, som vi
opsatte masters kerne.  Hvis du vil starte med en ren
opsætningsfil, kan du altid genskabe standard
<path>/usr/src/linux/.config</path> filen ved at taste:
</p>

<pre caption="Genskabelse af en ren kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make mrproper</i>
</pre>

<p>
Gå nu ind i opsætningsGUIen ved at taste:
</p>

<pre caption="Redigering af slaves kerneopsætning">
# <i>cd /usr/src/linux</i>
# <i>make menuconfig</i>
</pre>

<p>
Du vil nok være sikker på at du har valgt de følgende indstillinger som indbygget
og <e>IKKE</e> som kerne-moduler:
</p>

<pre caption="slaves kerneindstillinger">
Code maturity level options  ---&gt;
  [*] Prompt for development and/or incomplete code/drivers

Networking options ---&gt;
  &lt;*&gt; Packet socket
  [ ]   Packet socket: mmapped IO
  &lt; &gt; Netlink device emulation
  [ ] Network packet filtering (replaces ipchains)
  [ ] Socket Filtering
  &lt;*&gt; Unix domain sockets
  [*] TCP/IP networking
  [*]   IP: multicasting
  [*]   IP: kernel level autoconfiguration
  [*]     IP: DHCP support (NEW)


File systems ---&gt;
  [*] /proc file system support
  [*] /dev file system support (EXPERIMENTAL)
  [*]   Automatically mount at boot
  Network File Systems  ---&gt;
    &lt;*&gt; file system support 
    [*]   Provide NFSv3 client support
    [*]   Root file system on NFS
</pre>

<p>
Nu mangler slaves kerne at blive kompileret.  Du skal være omhyggelig her,
idet du ikke ønsker at ødelægge modulerne (hvis nogen) som du har bygget til 
master:
</p>

<pre caption="Kompilering af slaves kerne">
# <i>cd /usr/src/linux</i>
# <i>make clean dep bzImage</i>
</pre>

<p>
Lav nu et bibliotek på master, som du vil bruge til at indeholde slaves filer
og krævede systemfiler. Vi bruger <path>/diskless</path>, men du kan vælge
den placering, som du ønsker.  Kopiér nu slaves bzImage ind i
<path>/diskless</path> biblioteket:
</p>

<pre caption="Kopiering af slaves kerne">
# <i>mkdir /diskless</i>
# <i>cp /usr/src/linux/arch/i386/boot/bzImage /diskless</i>
</pre>

</body>
</section>
<section>
<title>Opsætning af en slaves indledende filsystem</title>
<body>

<p>
Masters og slaves filsystemer kan blive fin-indstillet og ændret en del.  Lige nu
er vi kun interesseret i at få lavet et indledende filsystem med passende
opsætningsfiler og mount-punkter. Først skal vi lave et bibliotek
inde i <path>/diskless</path> til den første slave.  Enhver slave kræver den egen
overordnet filsystem, fordi at dele specifikke systemfiler kan skabe problemer med
rettigheder og problems og det hele går ned.  Du kan kalde de biblioteker alt hvad du ønsker,
men vi foreslår at bruge slavernes IP-adresser, idet de er unikke og ikke
misledende.  Den statiske IP på vores første slave vil være, f.eks.
<c>192.168.1.21</c>:
</p>

<pre caption="Oprettelse af et fjernstyret rodbibliotek">
# <i>mkdir /diskless/192.168.1.21</i>
</pre>

<p>
Forskellige opsætningsfiler i <path>/etc</path> skal modificeres for at virke på
slaven. Kopiér masters <path>/etc</path>-bibliotek ind i din nye
slaves rod ved at taste:
</p>

<pre caption="Oprettelse af /etc til slaves filsystem">
# <i>cp -r /etc /diskless/192.168.1.21/etc</i>
</pre>

<p>
Stadigvæk er filsystemet ikke klart, fordi at den kræver flere mount-punkter og
biblioteker. For at oprette dem, tast:
</p>

<pre caption="Oprettelse af mount-punkter og biblioteker til slaves filsystem">
# <i>mkdir /diskless/192.168.1.21/home</i>
# <i>mkdir /diskless/192.168.1.21/dev</i>
# <i>mkdir /diskless/192.168.1.21/proc</i>
# <i>mkdir /diskless/192.168.1.21/tmp</i>
# <i>mkdir /diskless/192.168.1.21/mnt</i>
# <i>mkdir /diskless/192.168.1.21/mnt/.initd</i>
# <i>mkdir /diskless/192.168.1.21/root</i>
# <i>mkdir /diskless/192.168.1.21/var</i>
# <i>mkdir /diskless/192.168.1.21/var/empty</i>
# <i>mkdir /diskless/192.168.1.21/var/lock</i>
# <i>mkdir /diskless/192.168.1.21/var/log</i>
# <i>mkdir /diskless/192.168.1.21/var/run</i>
<comment>(Kun for openMosix)</comment>
# <i>mkdir /diskless/192.168.1.21/mfs</i>
</pre>

<p>
De fleste af disse "stumper" skulle være forståeligt for dig; Stumper som
<path>/dev</path> eller <path>/proc</path> vil være befolket, når slaven starter,
de andre vil blive mountet senere. Du skulle også ændre
<path>/diskless/192.168.1.21/etc/hostname</path>-filen til at vise værtnavnet til
slave. Binære filer, biblioteker (libs) og andre filer vil blive befolket senere i
denne HOWTO lige før du vil prøve at starte slave.
</p>

</body>
</section>
</chapter>


<chapter>
<title>Configuring the DHCP server</title>
<section>
<title>About the DHCP server</title>
<body>

<p>
DHCP stands for Dynamic Host Configuration Protocol.  The DHCP server is the 
first computer the slaves will communicate with when they PXE boot.  The 
primary purpose of the DHCP server is to assign IP addresses.  The DHCP server 
can assign IP addresses based on hosts ethernet MAC addresses.  Once the slave 
has an IP address, the DHCP server will tell the slave where to get its 
initial file system and kernel.
</p>

</body>
</section>
<section>
<title>Before you get started</title>
<body>

<p>
There are several things you will want to make sure are working before you 
begin.  First check your network connectivity:
</p>

<pre caption="Checking networking configurations">
# <i>ifconfig eth0 enable multicast</i>
# <i>ifconfig -a</i>
</pre>

<p>
You will want to make sure you have have an <e>eth0</e> device running.  It 
should look something like this:
</p>

<pre caption="A properly working eth0 device">
eth0      Link encap:Ethernet  HWaddr 00:E0:83:16:2F:D6
          inet addr:192.168.1.1  Bcast:192.168.1.255  Mask:255.255.255.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:26460491 errors:0 dropped:0 overruns:2 frame:0
          TX packets:32903198 errors:0 dropped:0 overruns:0 carrier:1
          collisions:0 txqueuelen:100
          RX bytes:2483502568 (2368.4 Mb)  TX bytes:1411984950 (1346.5 Mb)
          Interrupt:18 Base address:0x1800
</pre>

<p>
It's important that is says <e>MULTICAST</e>, if doesn't then you will have to
recompile your kernel to include multicast support.
</p>

</body>
</section>
<section>
<title>Installing the DHCP server</title>
<body>

<p>
If your network does not already have a DHCP server installed  you will need 
to install one:
</p>

<pre caption="Installing the dhcp server">
# <i>emerge dhcp</i>
</pre>

<p>
If your network already has a DHCP server installed you will have to edit the 
configuration file to get the PXE boot to function correctly.
</p>

</body>
</section>
<section>
<title>Configuring the DHCP server</title>
<body>

<p>
There is only one configuration file you will have to edit before starting the
DHCP server: <path>/etc/dhcp/dhcpd.conf</path>.  Copy and edit the provided
sample file:
</p>

<pre caption="Editing the dhcp server's configuration file">
# <i>cp /etc/dhcp/dhcpd.conf.sample /etc/dhcp/dhcpd.conf</i>
# <i>nano -w /etc/dhcp/dhcpd.conf</i>
</pre>

<p>
The general layout of the file is set up in an indented fashion and looks 
like this:
</p>

<pre caption="Sample dhcpd.conf layout">
<comment># global options here</comment>
ddns-update-style none;
shared-network LOCAL-NET {
<comment># shared network options here</comment>
subnet 192.168.1.0 netmask 255.255.255.0 {
<comment>    # subnet network options here</comment>
    host slave{
<comment>        # host specific options here</comment>
    }
    group {
<comment>        # group specific options here</comment>
    }
}
}
</pre>

<p>
The <c>shared-network</c> block is optional and should be used for IPs you want 
to assign that belong to the same network topology.  At least one <c>subnet</c>
must be declared and the optional <c>group</c> block allows you to group options
between items. A good example of <path>dhcpd.conf</path> looks like this:
</p>

<pre caption="Sample dhcpd.conf">
# DHCP configuration file for DHCP ISC 3.0
 
ddns-update-style none;
 
# Definition of PXE-specific options
# Code 1: Multicast IP address of boot file server
# Code 2: UDP port that client should monitor for MTFTP responses
# Code 3: UDP port that MTFTP servers are using to listen for MTFTP requests
# Code 4: Number of seconds a client must listen for activity before trying
#         to start a new MTFTP transfer
# Code 5: Number of seconds a client must listen before trying to restart
#         a MTFTP transfer
 
option space PXE;
option PXE.mtftp-ip               code 1 = ip-address;
option PXE.mtftp-cport            code 2 = unsigned integer 16;
option PXE.mtftp-sport            code 3 = unsigned integer 16;
option PXE.mtftp-tmout            code 4 = unsigned integer 8;
option PXE.mtftp-delay            code 5 = unsigned integer 8;
option PXE.discovery-control      code 6 = unsigned integer 8;
option PXE.discovery-mcast-addr   code 7 = ip-address;
 
subnet 192.168.1.0 netmask 255.255.255.0 {
 
  class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    option vendor-class-identifier "PXEClient";
    vendor-option-space PXE;
 
    # At least one of the vendor-specific PXE options must be set in
    # order for the client boot ROMs to realize that we are a PXE-compliant
    # server.  We set the MCAST IP address to 0.0.0.0 to tell the boot ROM
    # that we can't provide multicast TFTP (address 0.0.0.0 means no
    # address).
 
    option PXE.mtftp-ip 0.0.0.0;
 
    # This is the name of the file the boot ROMs should download.
    filename "pxelinux.0";
    # This is the name of the server they should get it from.
    <comment># Use the master's IP</comment>
    next-server 192.168.1.1;
  }
 
  pool {
    max-lease-time 86400;
    default-lease-time 86400;
    <comment># This prevents unlisted machines from getting an IP</comment>
    deny unknown clients;
  }
 
  host slave21 {
       <comment># Use your slave's MAC address</comment>
       hardware ethernet                00:40:63:C2:CA:C9;
       <comment># Give your slave a static IP</comment>
       fixed-address                    192.168.1.21;
       server-name                      "master";
       <comment># Use your gateway IP, if required</comment>
       option routers                   192.168.1.1;
       <comment># Use your DNS IP, if required</comment>
       option domain-name-servers       192.168.1.1;
       option domain-name               "mydomain.com";
       <comment># Use your slave hostname</comment>
       option host-name                 "slave21";
  }
}
</pre>

<p>
The IP address after <c>next-server</c> will be asked for the specified 
<c>filename</c>. This IP address should be the IP of the tftp server, usually 
the same as the master's IP address.  The <c>filename</c> is relative to the
<path>/diskless</path> directory (this is due to the tftp server specific 
options which will be covered later).  Inside the <c>host</c> block, the 
<c>hardware ethernet</c> option specifies a MAC address, and 
<c>fixed-address</c> assigns a fixed IP address to that particular MAC address.
The <c>host-name</c> option is probably a good idea to include and is just the 
hostname of a particular slave.  There is a pretty good man page on 
<path>dhcpd.conf</path> with options that are beyond the scope of this HOWTO.
You can read it by typing:
</p>

<pre caption="Viewing the man pages for dhcpd.conf">
# <i>man dhcpd.conf</i>
</pre>

</body>
</section>
<section>
<title>Starting the DHCP server</title>
<body>

<p>
Before you start the dhcp initialisation script edit the 
<path>/etc/conf.d/dhcp</path> file so that it looks something like 
this:
</p>

<pre caption="Sample /etc/conf.d/dhcp">
IFACE="eth0"
<comment># insert any other options needed</comment>
DHCPD_OPTS="-d"
</pre>

<p>
The -d flag is for verbose debugging. The <c>IFACE</c> variable is the device 
you wish to run your DHCP server on, in our case <c>eth0</c>. Adding more 
arguments to the <c>IFACE</c> variable can be useful for a complex network 
topology with multiple Ethernet cards. To start the dhcp server type:  
</p>

<pre caption="Starting the dhcp server on the master">
# <i>/etc/init.d/dhcp start</i>
</pre>

<p>
To add the dhcp server to your start-up scripts type:
</p>

<pre caption="Adding the dhcp server to the master's default run level">
# <i>rc-update add dhcp default</i>
</pre>

</body>
</section>
<section>
<title>Troubleshooting the DHCP server</title>
<body>

<p>
To see if a node boots you can take a look at 
<path>/var/log/daemon.log</path>.  If the node successfully boots the <path>daemon.log</path> file should look like this:
</p>

<pre caption="Sample dhcp log file">
DHCPDISCOVER from 00:00:00:00:00:00 via eth0
DHCPOFFER on 192.168.1.21 to 00:00:00:00:00:00 via eth0
DHCPREQUEST for 192.168.1.21 from 00:00:00:00:00:00 via eth0
DHCPACK on 192.168.1.21 to 00:00:00:00:00:00 via eth0
</pre>

<note>
This log file can also help you discover the slaves' MAC addresses.
</note>

<p>
If you get the following message it probably means there is something wrong 
in the configuration file but that the DHCP server is broadcasting correctly.
</p>

<pre caption="Sample dhpc server error">
no free leases on subnet LOCAL-NET
</pre>

<p>
Every time you change the configuration file you must restart the DHCP server.
To restart the server type:
</p>

<pre caption="Restarting the dhcp server on the master">
# <i>/etc/init.d/dhcpd restart</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Configuring the TFTP server and PXE Linux Bootloader</title>
<section>
<title>About the TFTP server</title>
<body>

<p>
TFTP stands for Trivial File Transfer Protocol.  The TFTP server is going to 
supply the slaves with a kernel and an initial filesystem.  All of the 
slave kernels and filesystems will be stored on the TFTP server, so it's 
probably a good idea to make the master the TFTP server.
</p>

</body>
</section>
<section>
<title>About PXELINUX</title>
<body>

<p>
PXELINUX is the network bootloader equivalent to LILO or GRUB and will be 
served via TFTP.  It is essentially a tiny set of instructions that tells the 
client where to locate its kernel and initial filesystem and allows for 
various kernel options.
</p>

</body>
</section>
<section>
<title>Before you get started</title>
<body>

<p>
You will need to get the pxelinux.0 file which comes in the SYSLINUX package 
by H. Peter Anvin.  You can install this package by typing:
</p>

<pre caption="Installing syslinux">
# <i>emerge syslinux</i>
</pre>

</body>
</section>
<section>
<title>Installing the TFTP server</title>
<body>

<p>
A highly recommended tftp server is available in the tftp-hpa package.  
This tftp server happens to be written by the author of SYSLINUX and it works 
very well with pxelinux. To install simply type:
</p>

<pre caption="Installing the tfp server">
# <i>emerge tftp-hpa</i>
</pre>

</body>
</section>
<section>
<title>Setting up PXELINUX</title>
<body>

<p>
Before you start your tftp server you need to setup pxelinux.  First copy 
the pxelinux binary into your <path>/diskless</path> directory:
</p>

<pre caption="Setting up the remote bootloader">
# <i>cp /usr/lib/syslinux/pxelinux.0 /diskless</i>
# <i>mkdir /diskless/pxelinux.cfg</i>
# <i>touch /diskless/pxelinux.cfg/default</i>
</pre>

<p>
This will create a default bootloader configuration file.  The binary 
<path>pxelinux.0</path> will look in the <path>pxelinux.cfg</path> directory 
for a file whose name is the client's IP address in hexadecimal. If it does not 
find that file it will remove the rightmost digit from the file name and try 
again until it runs out of digits. Versions 2.05 and later of syslinux do an 
extra search for a file named after the MAC address. If no file is found, it 
uses the <path>default</path> file.
</p>

<pre caption="Files that PXE looks for in pxelinux.cfg/ in sequence">
<comment>(Assigned IP in hexadecimal)</comment>
C0A80115
C0A8011
C0A801
C0A80
C0A8
C0A
C0
C
<comment>(Leading 01 means Ethernet, next bytes match our slave's MAC address)</comment>
01-00-40-63-c2-ca-c9
default
</pre>

<p>
Let's start with the <path>default</path> file:
</p>


<pre caption="Sample pxelinux.cfg/default">
DEFAULT /diskless/bzImage
APPEND ip=dhcp root=/dev/nfs nfsroot=192.168.1.1:/diskless/192.168.1.21
</pre>

<p>
The <c>DEFAULT</c> tag directs pxelinux to the kernel bzImage that we compiled
earlier.  The <c>APPEND</c> tag appends kernel initialisation options. Since we
compiled the slave kernel with <c>NFS_ROOT_SUPPORT</c>, we will specify the
nfsroot here.  The first IP is the master's IP and the second IP is the
directory that was created in <path>/diskless</path> to store the slave's
initial filesystem. 
</p>

</body>
</section>
<section>
<title>Configuring the TFTP server</title>
<body>

<p>
Edit <path>/etc/conf.d/in.tftpd</path>.  You need to specify the tftproot
directory with <c>INTFTPD_PATH</c> and any command line options with
<c>INTFTPD_OPTS</c>.  It should look something like this:
</p>

<pre caption="Sample /etc/conf.d/in.tftpd">
INTFTPD_PATH="/diskless"
INTFTPD_OPTS="-l -v -s ${INTFTPD_PATH}"
</pre>

<p>
The <c>-l</c> option indicates that this server listens in stand alone mode so 
you dont have to run inetd. The <c>-v</c> indicates that log/error messages 
should be verbose.  The <c>-s /diskless</c> specifies the root of your tftp 
server.
</p>

</body>
</section>
<section>
<title>Starting the the TFTP Server</title>
<body>

<p>
To start the tftp server type:
</p>

<pre caption="Starting the master's tftp server">
# <i>/etc/init.d/in.tftpd start</i>
</pre>

<p>
This should start the tftp server with the options you specified in the
<path>/etc/conf.d/in.tfpd</path>. If you want this server to be automatically
started at boot type:
</p>

<pre caption="Adding the tftp server to the master's default run level">
# <i>rc-update add in.tftpd default</i>
</pre>

</body>
</section>
<section>
<title>Troubleshooting the network boot process</title>
<body>

<p>
There are a few things you can do to debug the network boot process.  Primarily
you can use a tool called <c>tcpdump</c>.  To install <c>tcpdump</c> type:
</p>

<pre caption="Installing tcpdump">
# <i>emerge tcpdump</i>
</pre>

<p>
Now you can listen to various network traffic and make sure your client/server 
interactions are functioning.  If something isn't working there are a few 
things you might want to check.  First make sure that the client/server is 
physically connected properly and that the networking cables are not damaged. 
If your client/server is not receiving requests on a particular port make sure 
that there is no firewall interference.  To listen to interaction between two 
computers type:
</p>

<pre caption="Listening to client and server interaction via tcpdump">
# <i>tcpdump host </i><comment>client_ip</comment><i> and </i><comment>server_ip</comment>
</pre>

<p>
You can also use <c>tcpdump</c> to listen on particular port such as the tftp 
port by typing:
</p>

<pre caption="Listening to the tftp server">
# <i>tcpdump port 69</i>
</pre>

<p>
A common error you might receive is: "PXE-E32: TFTP open time-out".
This is probably due to firewall issues.  If you are using <c>TCPwrappers</c>, 
you might want to check <path>/etc/hosts.allow</path> and 
<path>etc/hosts.deny</path> and make sure that they are configured properly. 
The client should be allowed to connect to the server.
</p>

</body>
</section>
</chapter>

<chapter>
<title>Configuring the NFS server</title>
<section>
<title>About the NFS server</title>
<body>

<p>
NFS stands for Network File System.  The NFS server will be used to serve 
directories to the slave. This part can be somewhat personalized later, but 
right now all we want is a preliminary slave node to boot diskless.
</p>

</body>
</section>
<section>
<title>About Portmapper</title>
<body>

<p>
Various client/server services do not listen on a particular port, but instead 
rely on RPCs (Remote Procedure Calls).  When the service is initialised it 
listens on a random port and then registers this port with the Portmapper 
utility.  NFS relies on RPCs and thus requires Portmapper to be running 
before it is started.
</p>

</body>
</section>
<section>
<title>Before you start</title>
<body>

<p>
The NFS Server needs kernel level support so if you don't have this you should 
recompile your master's kernel.  To double check your master's kernel 
configuration type:
</p>

<pre caption="Checking for NFS specific options">
# <i>grep NFS /usr/src/linux/.config_master</i>
</pre>

<p>
You should see output that looks something like this if your kernel has been 
properly configured:
</p>

<pre caption="Proper NFS specific options in the master's kernel configuration">
# CONFIG_ROOT_NFS is not set
CONFIG_NFSD=y
CONFIG_NFSD_V3=y
# CONFIG_NFSD_TCP is not set
# CONFIG_NCPFS_NFS_NS is not set
</pre>

</body>
</section>
<section>
<title>Installing the NFS server</title>
<body>

<p>
The NFS package that can be acquired through portage by typing:
</p>

<pre caption="Installing nfs-utils">
# <i>emerge nfs-utils</i>
</pre>

<p>
This package will emerge a portmapping utility, nfs server, and nfs client 
utilities and will automatically handle initialisation dependencies.
</p>

</body>
</section>
<section>
<title>Configuring the NFS server</title>
<body>

<p>
There are three major configuration files you will have to edit:
</p>

<pre caption="Nfs configuration files">
/etc/exports
/diskless/192.168.1.21/etc/fstab
/etc/conf.d/nfs
</pre>

<p>
The <path>/etc/exports</path> file specifies how, to who and what to export 
through NFS.  The slave's fstab will be altered so that it can mount the NFS 
filesystems that the master is exporting.
</p>

<p>
A typical <path>/etc/exports</path> for the master should look something like 
this:
</p>

<pre caption="Sample master /etc/exports">
<comment># one line like this for each slave</comment>
/diskless/192.168.1.21   192.168.1.21(rw,no_root_squash,no_all_squash)
<comment># common to all slaves</comment>
/opt   192.168.1.0/24(ro,no_root_squash,no_all_squash)
/usr   192.168.1.0/24(ro,no_root_squash,no_all_squash)
/home  192.168.1.0/24(rw,no_root_squash,no_all_squash)
<comment># if you want to have a shared log</comment>
/var/log   192.168.1.21(rw,no_root_squash,no_all_squash)
</pre>

<p>
The first field indicates the directory to be exported and the next field 
indicates to who and how. This field can be divided in two parts: who should be
allowed to mount that particular directory, and what the mounting 
client can do to the filesystem: <c>ro</c> for read only, <c>rw</c> for 
read/write; <c>no_root_squash</c> and <c>no_all_squash</c>  are 
important for diskless clients that are writing to the disk, so that they 
don't get "squashed" when making I/O requests.  The slave's fstab file,
<path>/diskless/192.168.1.21/etc/fstab</path>, should look like 
this:
</p>

<pre caption="Sample slave fstab">
<comment># these entries are essential</comment>
master:/diskless/192.168.1.21   /         nfs     hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
master:/opt                     /opt      nfs     hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/usr                     /usr      nfs     hard,intr,ro,nolock,rsize=8192,wsize=8192    0 0
master:/home                    /home     nfs     hard,intr,rw,nolock,rsize=8192,wsize=8192    0 0
none                            /proc     proc    defaults                                     0 0
<comment># useful but superfluous</comment>
master:/var/log                 /var/log  nfs     hard,intr,rw                                 0 0

<comment>(if you are setting up an openMosix cluster only)</comment>
none                            /mfs      mfs     dfsa=1                                       0 0
</pre>

<p>
In this example, <e>master</e> is just the hostname of the master but it could
easily be the IP of the master.  The first field indicates the directory to be
mounted and the second field indicates where.  The third field describes the
filesystem and  should be NFS for any NFS mounted directory. The fourth field
indicates various options that will be used in the mounting process (see
mount(1) for info on mount options).  Some people have had difficulties with 
soft mount points so we made them all hard, but you should look into various
<path>/etc/fstab</path> options to make your cluster more efficient. 
</p>

<p>
The last file you should edit is <path>/etc/conf.d/nfs</path> which 
describes a few options for nfs when it is initialised and looks like this:
</p>

<pre caption="Sample master /etc/conf.d/nfs">
# Config file for /etc/init.d/nfs

# Number of servers to be started up by default
RPCNFSDCOUNT=8

# Options to pass to rpc.mountd
RPCMOUNTDOPTS=""
</pre>

<p>
You should change <c>RPCNFSDCOUNT</c> to the number of diskless nodes on the
network.
</p>

</body>
</section>
<section>
<title>Starting the NFS server</title>
<body>

<p>
You should start the nfs server with its init script located in 
<path>/etc/init.d</path> by typing:
</p>

<pre caption="Starting the master's nfs server">
# <i>/etc/init.d/nfs start</i>
</pre>

<p>
If you want to this script to start when the system boots simply type:
</p>

<pre caption="Adding the nfs server to the master's default run level">
# <i>rc-update add nfs default</i>
</pre>

</body>
</section>
</chapter>

<chapter>
<title>Completing the slave filesystem</title>
<section>
<title>Copy the missing files</title>
<body>

<p>
We will now make the slave's file system in sync with the master's and provide 
the necessary binaries while still preserving slave specific files.
</p>

<pre caption="Creating a slave filesystem">
# <i>cp -r /bin /diskless/192.168.1.21/bin</i>
# <i>cp -r /sbin /diskless/192.168.1.21/sbin </i>
# <i>cp -r /lib /diskless/192.168.1.21/lib </i>
</pre>

</body>
</section>
<section>
<title>Initialisation scripts</title>
<body>

<p>
The default scripts will try to run <e>checkroot</e> which does not make sense
on your slave nodes. The hard way out is to manually edit the
<path>/diskless/192.168.1.21/sbin/rc</path> script but this is cumbersome,
dangerous and could break if you decided to sync your node file system again
and forgot to leave this script alone.  The trick is to have a
<path>/fastboot</path> file when your system boots. This file tells
<e>checkroot</e> not to run any file system check. But it will also erase the
file when it has finished the initialisation process. That is why we need to
create this file again at the end of the init process like this:
</p>

<pre caption="Preventing init scripts from running a file system check">
<comment>(Create the /fastboot file for next reboot)</comment>
# <i>touch /diskless/192.168.1.21/fastboot</i>
<comment>(Create the /fastboot file on each boot)</comment>
# <i>echo "touch /fastboot" &gt;&gt; /diskless/192.168.1.21/etc/conf.d/local.start</i>
</pre>

<p>
You need as many init scripts under
<path>/diskless/192.168.1.21/etc/runlevel</path> as you need services on your
diskless nodes. It all depends on what you want your slaves to do.
</p>

<warn>
Do not use the <c>rc-update</c> program to add or remove scripts from the
slave runlevels when logged on your master. This would change your master
runlevels. You need to create the links manually or log into your slave nodes
using ssh or connect a screen and keyboard to your slave.
</warn>

<pre caption="Typical slave runlevels">
/diskless/192.168.1.21/etc/runlevels/:
total 16
drwxr-xr-x    2 root     root         4096 2003-11-09 15:27 boot
drwxr-xr-x    2 root     root         4096 2003-10-01 21:10 default
drwxr-xr-x    2 root     root         4096 2003-03-13 19:05 nonetwork
drwxr-xr-x    2 root     root         4096 2003-02-23 12:26 single
 
/diskless/192.168.1.21/etc/runlevels/boot:
total 0
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 bootmisc -> /etc/init.d/bootmisc
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 checkfs -> /etc/init.d/checkfs
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           23 2003-10-18 17:28 consolefont -> /etc/init.d/consolefont
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 hostname -> /etc/init.d/hostname
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 keymaps -> /etc/init.d/keymaps
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 localmount -> /etc/init.d/localmount
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 net.lo -> /etc/init.d/net.lo
lrwxrwxrwx    1 root     root           20 2003-10-18 17:28 netmount -> /etc/init.d/netmount
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 portmap -> /etc/init.d/portmap
lrwxrwxrwx    1 root     root           21 2003-10-18 17:28 rmnologin -> /etc/init.d/rmnologin
lrwxrwxrwx    1 root     root           18 2003-10-18 17:28 serial -> /etc/init.d/serial
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 urandom -> /etc/init.d/urandom
 
/diskless/192.168.1.21/etc/runlevels/default:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 clock -> /etc/init.d/clock
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 distccd -> /etc/init.d/distccd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
lrwxrwxrwx    1 root     root           19 2003-10-18 17:28 metalog -> /etc/init.d/metalog
lrwxrwxrwx    1 root     root           22 2003-10-18 17:28 ntp-client -> /etc/init.d/ntp-client
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 ntpd -> /etc/init.d/ntpd
lrwxrwxrwx    1 root     root           16 2003-10-18 17:28 sshd -> /etc/init.d/sshd
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 vcron -> /etc/init.d/vcron
 
/diskless/192.168.1.21/etc/runlevels/nonetwork:
total 0
lrwxrwxrwx    1 root     root           17 2003-10-18 17:28 local -> /etc/init.d/local
 
/diskless/192.168.1.21/etc/runlevels/single:
total 0
</pre>

<p>
Now is a good time to boot your slave and cross your fingers. It works?
Congratulations, you are now the proud owner of (a) diskless node(s) :)
</p>

</body>
</section>

<!-- 

<section>
<title>An alternative : ClusterNFS</title>
<body>

<warn>
This is mentioned only because a reviewer of this document is using this
solution. Be aware that Gentoo <e>does not</e> support ClusterNFS. It is not in
portage and requires changes to a baselayout init script. <b>Use at your own
risks</b>.
</warn>

<p>
If you don't fancy having a distinct root for each slave because it needs some
maintenance when upgrading files from the master directories, you could share 
the same root across all nodes, master and slaves included. This means all your
machines need to be compatible because you will have only one set of binaries.
You also need to be aware that this might have security issues because all of
your master root will be exported through NFS.
</p>

<p>
If you still want to try out this alternative, visit the ClusterNFS <uri
link="http://clusternfs.sourceforge.net/">home page</uri>, download the
software and read the doc.
</p>

<p>
To make it short, all files are shared and the files that need to be different
between master and all slaves are copied to <path>file$$CLIENT$$</path>. When a
slave requests <path>file</path>, ClusterNFS will notice the existence of
<path>file$$CLIENT$$</path> and send it instead. Files that need to be
different on each node are copied to <path>file$$IP=192.168.1.21$$</path>.
The same applies to directories.
</p>

<p>
Very shortly, this is what differs from the installation procedure described 
above:
</p>

<ul>
  <li>You do not need NFS server support in your master kernel</li>
  <li>Install ClusterNFS <e>after</e> you emerge nfs-utils</li>
  <li>Make slave copies of files and directories as described below</li>
  <li>Do not create a root dir for each node</li>
  <li>Export only / in your <path>/etc/exports</path> file</li>
  <li>
    Only mount / via NFS in the slave <path>/etc/fstab$$CLIENT$$</path> file
  </li>
  <li>Edit <path>/etc/init.d/nfs</path> as described below</li>
  <li>
    Edit <path>/etc/conf.d/local.start$$CLIENT$$</path> as described below
  </li>
</ul>

<pre caption="Files that need to be different between master and slaves">
/etc/conf.d/local.start$$CLIENT$$
/etc/conf.d/local.stop$$CLIENT$$<comment> (Probably empty)</comment>
/etc/crontab$$CLIENT$$<comment> (Probably empty, master takes care of chores)</comment>
/etc/exports$$CLIENT$$<comment> (Empty, slaves do not export NFS mounts)</comment>
/etc/fstab$$CLIENT$$
/etc/hostname$$IP=192.168.1.21$$<comment> (Name your slaves)</comment>
/etc/mtab$$IP=192.168.1.21$$
/etc/runlevels$$CLIENT$$<comment> (Clean separation between master and slave boot scripts)</comment>
/fastboot$$CLIENT$$
/tmp$$IP=192.168.1.21$$
/var$$IP=192.168.1.21$$<comment> (Create subdirs as in /var)</comment>
</pre>

<pre caption="Editing /etc/init.d/nfs">
        ebegin "Starting NFS daemon"
        start-stop-daemon - -start - -quiet - -exec \
<comment># Add - -translate-names option</comment>
                $nfsd - - - -translate-names
        eend $? "Error starting NFS daemon"
         # Check if we support NFSv3
        ebegin "Starting NFS mountd"
<comment># Comment the following two lines (ClusterNFS only knows NFS v2)</comment>
#       rpcinfo -u localhost nfs 3 &amp;&gt;/dev/null || \
#               RPCMOUNTDOPTS="$RPCMOUNTDOPTS - -no-nfs-version 3"
        start-stop-daemon - -start - -quiet - -exec \
                $mountd - - $RPCMOUNTDOPTS 1&gt;&amp;2
        eend $? "Error starting NFS mountd"
</pre>

<pre caption="Editing /etc/conf.d/local.start$$CLIENT$$">
<comment>(Add this line)</comment>
touch /fastboot\$\$CLIENT\$\$
</pre>

</body>
</section>
-->
</chapter>

</guide>
